[
  {
    "projectId": "1291ddd9-4170-4422-a6dd-3f8ef1de3ce2",
    "testId": "f01dbf51-1661-40c3-870a-ab4eec3586cb",
    "userId": "84d834c8-9081-7041-b0fc-d2d44446a587",
    "title": "TC001-Login success with valid credentials",
    "description": "Verify that the login form accepts valid credentials (User ID: 1111, Password: 1111) and redirects the user to the protected dashboard page with a welcome message.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:4173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click the 'Enter Dashboard' button to reveal the inline login form.\n        frame = context.pages[-1]\n        # Click the 'Enter Dashboard' button to reveal the inline login form.\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Enter User ID as '1111' and Password as '1111'.\n        frame = context.pages[-1]\n        # Enter User ID as '1111'\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1111')\n        \n\n        frame = context.pages[-1]\n        # Enter Password as '1111'\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1111')\n        \n\n        # -> Click the login button to submit the form.\n        frame = context.pages[-1]\n        # Click the login button.\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[3]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Welcome, 1111').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Logout').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84d834c8-9081-7041-b0fc-d2d44446a587/1761220124588538//tmp/test_task/result.webm",
    "created": "2025-10-23T11:46:36.556Z",
    "modified": "2025-10-23T11:48:44.711Z"
  },
  {
    "projectId": "1291ddd9-4170-4422-a6dd-3f8ef1de3ce2",
    "testId": "52bb63b3-5733-45a6-bd09-6272021d3a91",
    "userId": "84d834c8-9081-7041-b0fc-d2d44446a587",
    "title": "TC002-Login failure with invalid credentials",
    "description": "Verify that the login form rejects invalid credentials and displays shake animations and error messages on both input fields.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:4173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click the 'Enter Dashboard' button to reveal the inline login form.\n        frame = context.pages[-1]\n        # Click the 'Enter Dashboard' button to reveal the inline login form.\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Enter invalid User ID and Password, then click the login button.\n        frame = context.pages[-1]\n        # Enter invalid User ID\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalidUser')\n        \n\n        frame = context.pages[-1]\n        # Enter invalid Password\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalidPass')\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Login').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=invalidUser').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=invalidPass').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84d834c8-9081-7041-b0fc-d2d44446a587/1761220229732878//tmp/test_task/result.webm",
    "created": "2025-10-23T11:46:36.563Z",
    "modified": "2025-10-23T11:50:29.906Z"
  },
  {
    "projectId": "1291ddd9-4170-4422-a6dd-3f8ef1de3ce2",
    "testId": "66713a86-06d2-489d-a618-05c78ce859fa",
    "userId": "84d834c8-9081-7041-b0fc-d2d44446a587",
    "title": "TC003-Login form validation for empty fields",
    "description": "Check that submitting the login form with empty User ID or Password fields triggers validation errors with shake animations and appropriate messages.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:4173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click the 'Enter Dashboard' button to reveal the login form.\n        frame = context.pages[-1]\n        # Click 'Enter Dashboard' button to reveal the inline login form.\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Login' button to submit the form with empty User ID and Password fields.\n        frame = context.pages[-1]\n        # Click the 'Login' button to submit the form with empty User ID and Password fields.\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[3]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # Check for validation error messages for empty User ID and Password fields\n        await expect(frame.locator('text=Please enter your User ID and Password').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84d834c8-9081-7041-b0fc-d2d44446a587/1761220213031403//tmp/test_task/result.webm",
    "created": "2025-10-23T11:46:36.569Z",
    "modified": "2025-10-23T11:50:13.300Z"
  },
  {
    "projectId": "1291ddd9-4170-4422-a6dd-3f8ef1de3ce2",
    "testId": "72c88f36-2426-40c8-87c7-4f698413f34d",
    "userId": "84d834c8-9081-7041-b0fc-d2d44446a587",
    "title": "TC004-Password visibility toggle functionality",
    "description": "Validate that clicking the Eye/EyeOff icon toggles the password input field visibility between masked and plain text.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:4173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click the 'Get Started' button to reveal the inline login form.\n        frame = context.pages[-1]\n        # Click the 'Get Started' button to reveal the inline login form.\n        elem = frame.locator('xpath=html/body/div/div/header/nav/div[3]/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Enter text 'TestPassword123' into the password input field.\n        frame = context.pages[-1]\n        # Enter text into the password field.\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        # -> Click the password visibility toggle icon to reveal the password text.\n        frame = context.pages[-1]\n        # Click the password visibility toggle icon next to the password field.\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the password visibility toggle icon again to mask the password field.\n        frame = context.pages[-1]\n        # Click the password visibility toggle icon again to mask the password field.\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        password_input = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[2]/input').nth(0)\n        # Assert password field is plain text after first toggle click\n        assert await password_input.get_attribute('type') == 'text'\n        # Click the toggle icon again to mask the password field\n        toggle_button = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[2]/button').nth(0)\n        await toggle_button.click(timeout=5000)\n        # Assert password field is masked (type='password') after second toggle click\n        assert await password_input.get_attribute('type') == 'password'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84d834c8-9081-7041-b0fc-d2d44446a587/1761220228983296//tmp/test_task/result.webm",
    "created": "2025-10-23T11:46:36.574Z",
    "modified": "2025-10-23T11:50:29.193Z"
  },
  {
    "projectId": "1291ddd9-4170-4422-a6dd-3f8ef1de3ce2",
    "testId": "391fc186-f8b4-40d9-b688-b06a6802d745",
    "userId": "84d834c8-9081-7041-b0fc-d2d44446a587",
    "title": "TC005-Session persistence across page refreshes",
    "description": "Ensure that once logged in, the user's authenticated state is persisted using localStorage and remains active after page reload, redirecting automatically to dashboard.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:4173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click 'Enter Dashboard' button to proceed to login or dashboard page.\n        frame = context.pages[-1]\n        # Click 'Enter Dashboard' button to proceed to login or dashboard page\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid User ID and Password, then click Login button to authenticate.\n        frame = context.pages[-1]\n        # Input valid User ID\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('validUser')\n        \n\n        frame = context.pages[-1]\n        # Input valid Password\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('validPassword')\n        \n\n        # -> Click 'Login' button to submit credentials and attempt login.\n        frame = context.pages[-1]\n        # Click 'Login' button to submit credentials and attempt login\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[3]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=User is not authenticated').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The user authentication state was not persisted after page reload, and the user was not redirected to the dashboard as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task to ensure authenticated state persistence using localStorage and automatic redirection to dashboard after page reload could not be fully completed because the login attempt failed with 'Invalid User ID or Password' error. No valid credentials were provided to perform a successful login. Therefore, the persistence of authentication state and redirection behavior could not be verified.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84d834c8-9081-7041-b0fc-d2d44446a587/1761220289740492//tmp/test_task/result.webm",
    "created": "2025-10-23T11:46:36.579Z",
    "modified": "2025-10-23T11:51:29.946Z"
  },
  {
    "projectId": "1291ddd9-4170-4422-a6dd-3f8ef1de3ce2",
    "testId": "ff43da81-e723-49c1-a2d1-f7bf139bde22",
    "userId": "84d834c8-9081-7041-b0fc-d2d44446a587",
    "title": "TC006-Logout clears session and redirects to landing page",
    "description": "Verify that clicking the logout button on the dashboard clears the stored session and redirects to the landing page with the login button visible.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:4173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click the 'Enter Dashboard' button to log in and arrive at the dashboard.\n        frame = context.pages[-1]\n        # Click the 'Enter Dashboard' button to log in and arrive at the dashboard.\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input User ID and Password, then click the Login button to log in and arrive at the dashboard.\n        frame = context.pages[-1]\n        # Input User ID\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser')\n        \n\n        frame = context.pages[-1]\n        # Input Password\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testpassword')\n        \n\n        # -> Click the Login button again to attempt login and arrive at the dashboard.\n        frame = context.pages[-1]\n        # Click the Login button to attempt login and arrive at the dashboard.\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[3]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Logout Successful - Session Cleared').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Clicking the logout button did not clear the session storage or redirect to the landing page with the 'Enter Dashboard' button visible as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login attempt failed with provided credentials. Cannot proceed to test logout functionality without successful login. Please provide valid credentials to continue testing logout behavior.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84d834c8-9081-7041-b0fc-d2d44446a587/1761220220685783//tmp/test_task/result.webm",
    "created": "2025-10-23T11:46:36.584Z",
    "modified": "2025-10-23T11:50:20.859Z"
  },
  {
    "projectId": "1291ddd9-4170-4422-a6dd-3f8ef1de3ce2",
    "testId": "f957387d-537c-4a4d-9fd8-30b3f6b21f3d",
    "userId": "84d834c8-9081-7041-b0fc-d2d44446a587",
    "title": "TC007-Protected route blocks unauthenticated access to dashboard",
    "description": "Ensure unauthenticated users attempting to access the dashboard URL directly get redirected to the landing page.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:4173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate directly to the dashboard URL without logging in to verify redirection to the landing page.\n        await page.goto('http://localhost:4173/dashboard', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Seamless Ticketing, Smarter Support').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84d834c8-9081-7041-b0fc-d2d44446a587/1761220136417388//tmp/test_task/result.webm",
    "created": "2025-10-23T11:46:36.590Z",
    "modified": "2025-10-23T11:48:56.589Z"
  },
  {
    "projectId": "1291ddd9-4170-4422-a6dd-3f8ef1de3ce2",
    "testId": "261edc07-e9f0-4be6-8176-4abe7881af9a",
    "userId": "84d834c8-9081-7041-b0fc-d2d44446a587",
    "title": "TC008-Public route redirects authenticated users from landing page to dashboard",
    "description": "Verify that authenticated users trying to access the landing page get redirected automatically to the dashboard.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:4173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Log in successfully.\n        frame = context.pages[-1]\n        # Click 'Get Started' button to initiate login process\n        elem = frame.locator('xpath=html/body/div/div/header/nav/div[3]/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Log in successfully by entering User ID and Password and clicking Login.\n        frame = context.pages[-1]\n        # Input User ID\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser')\n        \n\n        frame = context.pages[-1]\n        # Input Password\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testpassword')\n        \n\n        # -> Handle unexpected element or retry login submission by clicking the Login button.\n        frame = context.pages[-1]\n        # Click Login button to submit credentials despite unexpected element\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[3]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Welcome to the Landing Page').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Authenticated users were not redirected to the dashboard and the landing page was accessed instead.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login attempt failed due to invalid credentials. Cannot proceed to test redirection without successful authentication. Please provide valid credentials to continue testing.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84d834c8-9081-7041-b0fc-d2d44446a587/176122022062017//tmp/test_task/result.webm",
    "created": "2025-10-23T11:46:36.595Z",
    "modified": "2025-10-23T11:50:20.770Z"
  },
  {
    "projectId": "1291ddd9-4170-4422-a6dd-3f8ef1de3ce2",
    "testId": "232db243-4c70-4e66-aa8b-37daed13b90c",
    "userId": "84d834c8-9081-7041-b0fc-d2d44446a587",
    "title": "TC009-Inline login form animation transition",
    "description": "Verify smooth fade/zoom animation transitions of 0.5s duration between 'Enter Dashboard' button and inline login form on the landing page.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:4173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click 'Enter Dashboard' button to trigger login form display and animation\n        frame = context.pages[-1]\n        # Click 'Enter Dashboard' button\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Go Back' button to trigger fade out of login form and fade in of 'Enter Dashboard' button, then verify animation timing\n        frame = context.pages[-1]\n        # Click 'Go Back' button to hide login form and trigger fade/zoom animation back to 'Enter Dashboard' button\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Enter Dashboard').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=One\\u00a0Work\\u00a0Platform\\u00a0To\\u00a0Manage\\u00a0Attendance\\u00a0&\\u00a0Tasks\\u00a0Effortlessly').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84d834c8-9081-7041-b0fc-d2d44446a587/1761220228263559//tmp/test_task/result.webm",
    "created": "2025-10-23T11:46:36.601Z",
    "modified": "2025-10-23T11:50:28.463Z"
  },
  {
    "projectId": "1291ddd9-4170-4422-a6dd-3f8ef1de3ce2",
    "testId": "162dfe2e-dad1-4f63-91c8-17fdbe7429f0",
    "userId": "84d834c8-9081-7041-b0fc-d2d44446a587",
    "title": "TC010-Dashboard preview carousel updates on hover and click",
    "description": "Validate that hovering and clicking on each of the nine dashboard option modules updates the preview image immediately on the landing pageâ€™s dashboard preview carousel.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:4173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Hover over the first dashboard option module (index 6) to check if the preview image updates immediately.\n        frame = context.pages[-1]\n        # Hover over 'Real-time updates' dashboard option module to check preview image update\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div[2]/div/div/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Hover over the second dashboard option module (index 7) to check if the preview image updates immediately.\n        frame = context.pages[-1]\n        # Hover over 'Simplified workflow' dashboard option module to check preview image update\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div[2]/div/div/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Hover over the third dashboard option module (index 8) to check if the preview image updates immediately.\n        frame = context.pages[-1]\n        # Hover over 'Insightful reports' dashboard option module to check preview image update\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div[2]/div/div/div[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Hover over the first dashboard option module (index 6) to verify immediate preview image update on hover.\n        frame = context.pages[-1]\n        # Hover over 'Real-time updates' dashboard option module to check preview image update\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div[2]/div/div/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Hover over the second dashboard option module (index 7) to verify immediate preview image update on hover.\n        frame = context.pages[-1]\n        # Hover over 'Simplified workflow' dashboard option module to check preview image update\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div[2]/div/div/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Hover over the third dashboard option module (index 8) to verify immediate preview image update on hover.\n        frame = context.pages[-1]\n        # Hover over 'Insightful reports' dashboard option module to check preview image update\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div[2]/div/div/div[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Hover over the fourth dashboard option module (index 10) to verify immediate preview image update on hover.\n        frame = context.pages[-1]\n        # Hover over 'Overview' dashboard option module to check preview image update\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div[3]/div/div[2]/div/div/div[2]/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Hover over the fifth dashboard option module (index 9) to verify immediate preview image update on hover.\n        frame = context.pages[-1]\n        # Hover over 'Overview' dashboard option module to check preview image update\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div[3]/div/div[2]/div/div/div[2]/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the fifth dashboard option module (index 9) to verify immediate preview image update on click.\n        frame = context.pages[-1]\n        # Click on 'Overview' dashboard option module to check preview image update\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div[3]/div/div[2]/div/div/div[2]/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Dashboard Preview Updated Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test plan failed: The preview image did not update immediately upon hovering or clicking on the dashboard option modules as required.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Validation of dashboard option modules preview image updates on hover and click is partially successful. Hover updates work for all tested modules. Click updates work for 4 out of 9 modules but fail on the fifth module (index 9). This is a critical issue that needs fixing. Stopping further testing as per instructions.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84d834c8-9081-7041-b0fc-d2d44446a587/1761220430866047//tmp/test_task/result.webm",
    "created": "2025-10-23T11:46:36.606Z",
    "modified": "2025-10-23T11:53:51.031Z"
  },
  {
    "projectId": "1291ddd9-4170-4422-a6dd-3f8ef1de3ce2",
    "testId": "2c54dc8d-3df7-405b-8c23-7607e68f552e",
    "userId": "84d834c8-9081-7041-b0fc-d2d44446a587",
    "title": "TC011-Sticky header navigation behavior on mobile devices",
    "description": "Test that the header navigation bar hides on scroll down and shows on scroll up on mobile devices (viewport <768px) while maintaining smooth scrolling to sections on link clicks.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:4173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Scroll down the page to test if the header navigation bar hides.\n        await page.mouse.wheel(0, 300)\n        \n\n        # -> Scroll up the page to test if the header navigation bar reappears.\n        await page.mouse.wheel(0, -300)\n        \n\n        # -> Click on a navigation link to test smooth scrolling to the target section.\n        frame = context.pages[-1]\n        # Click 'Contact us' navigation button to test smooth scrolling to the target section.\n        elem = frame.locator('xpath=html/body/div/div/header/nav/div[3]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Manually inspect the header navigation bar's visibility or style attribute by scrolling down and up and checking for changes in the header element's style or class attribute.\n        await page.mouse.wheel(0, 300)\n        \n\n        # -> Scroll up the page to test if the header navigation bar reappears visually or by style attribute.\n        await page.mouse.wheel(0, -300)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Contact us').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Tired of the spreadsheet chaos?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Seamless Ticketing, Smarter Support').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84d834c8-9081-7041-b0fc-d2d44446a587/1761220295619899//tmp/test_task/result.webm",
    "created": "2025-10-23T11:46:36.611Z",
    "modified": "2025-10-23T11:51:35.808Z"
  },
  {
    "projectId": "1291ddd9-4170-4422-a6dd-3f8ef1de3ce2",
    "testId": "cf8a3d2c-a760-4906-8fdf-d016482ee54f",
    "userId": "84d834c8-9081-7041-b0fc-d2d44446a587",
    "title": "TC012-Scroll-triggered animations with Intersection Observer",
    "description": "Verify that various landing page sections trigger staggered animations when scrolled into view using Intersection Observer, and that unobserving occurs after animation to optimize performance.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:4173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Scroll through highlights, features, benefits, about, and footer sections one by one to observe staggered animations.\n        await page.mouse.wheel(0, 600)\n        \n\n        # -> Continue scrolling down to features section to observe staggered animations.\n        await page.mouse.wheel(0, 600)\n        \n\n        # -> Scroll down to benefits section and observe staggered animations triggering.\n        await page.mouse.wheel(0, 600)\n        \n\n        # -> Scroll down to the about section and observe staggered animations triggering.\n        await page.mouse.wheel(0, 600)\n        \n\n        # -> Scroll down to the footer section and observe staggered animations triggering.\n        await page.mouse.wheel(0, 600)\n        \n\n        # -> Scroll back up and down repeatedly to verify animations do not retrigger and Intersection Observer stops observing after first animation.\n        await page.mouse.wheel(0, -1200)\n        \n\n        # -> Scroll down and up repeatedly to verify animations do not retrigger and Intersection Observer stops observing after first animation.\n        await page.mouse.wheel(0, -600)\n        \n\n        await page.mouse.wheel(0, 600)\n        \n\n        await page.mouse.wheel(0, -600)\n        \n\n        await page.mouse.wheel(0, 600)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Seamless Ticketing, Smarter Support').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Real-time updates').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Simplified workflow').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Insightful reports').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=About').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Contact us').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Get Started').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Seamless attendance, smarter task management, and simpler leave cycles.').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84d834c8-9081-7041-b0fc-d2d44446a587/1761220230037558//tmp/test_task/result.webm",
    "created": "2025-10-23T11:46:36.617Z",
    "modified": "2025-10-23T11:50:30.243Z"
  },
  {
    "projectId": "1291ddd9-4170-4422-a6dd-3f8ef1de3ce2",
    "testId": "497b2ad9-5d38-45fd-a96f-b2f8afa2bc23",
    "userId": "84d834c8-9081-7041-b0fc-d2d44446a587",
    "title": "TC013-Mobile Highlights carousel auto-rotation",
    "description": "Test auto-rotation every 3 seconds of the mobile highlights carousel with smooth fade and scale transitions cycling through system highlight messages.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:4173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Real-time updates').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Simplified workflow').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Insightful reports').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84d834c8-9081-7041-b0fc-d2d44446a587/1761220157537038//tmp/test_task/result.webm",
    "created": "2025-10-23T11:46:36.622Z",
    "modified": "2025-10-23T11:49:17.762Z"
  },
  {
    "projectId": "1291ddd9-4170-4422-a6dd-3f8ef1de3ce2",
    "testId": "36519e9a-d4f2-4430-a86e-69acf6e24fb9",
    "userId": "84d834c8-9081-7041-b0fc-d2d44446a587",
    "title": "TC014-Keyboard navigation and accessibility in login form",
    "description": "Verify that input fields in the login form support keyboard navigation with Enter key moving focus between User ID, Password, and Login button, and that auto-focus sets on User ID field when form appears.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:4173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click the 'Get Started' button to reveal the inline login form.\n        frame = context.pages[-1]\n        # Click the 'Get Started' button to reveal the inline login form.\n        elem = frame.locator('xpath=html/body/div/div/header/nav/div[3]/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Check if the User ID input field (index 5) is auto-focused.\n        frame = context.pages[-1]\n        # Click User ID input field to check focus state.\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Explicitly check if User ID input is auto-focused. If not, focus it manually, then type User ID and press Enter to test focus move to Password input.\n        frame = context.pages[-1]\n        # Click User ID input field to ensure it is focused.\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Type User ID 'testuser' into User ID input field.\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser')\n        \n\n        # -> Click Password input field (index 6) to focus it, then type password and press Enter to check if focus moves to Login button.\n        frame = context.pages[-1]\n        # Click Password input field to focus it.\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input password 'password123' into Password field (index 6) and press Enter key to check focus move to Login button.\n        frame = context.pages[-1]\n        # Type password 'password123' into Password input field.\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        # -> Click Login button (index 9) to verify focus and press Enter key to submit the form.\n        frame = context.pages[-1]\n        # Click Login button to verify focus.\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[4]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('input[autofocus]').first).to_be_visible(timeout=30000)  # Check that User ID input is auto-focused\n        await expect(frame.locator('input').nth(0)).to_be_focused()  # User ID input should be focused initially\n        # After typing User ID and pressing Enter, focus should move to Password input\n        await frame.locator('input').nth(0).fill('testuser')\n        await frame.keyboard.press('Enter')\n        await expect(frame.locator('input').nth(1)).to_be_focused()  # Password input should be focused\n        # After typing Password and pressing Enter, focus should move to Login button\n        await frame.locator('input').nth(1).fill('password123')\n        await frame.keyboard.press('Enter')\n        await expect(frame.locator('button:has-text(\"Login\")').first).to_be_focused()  # Login button should be focused\n        # Press Enter key to submit the form\n        await frame.keyboard.press('Enter')\n        # Verify form submission or validation by checking for error message or success indicator\n        await expect(frame.locator('text=Invalid User ID or Password').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84d834c8-9081-7041-b0fc-d2d44446a587/1761220318172101//tmp/test_task/result.webm",
    "created": "2025-10-23T11:46:36.628Z",
    "modified": "2025-10-23T11:51:58.327Z"
  },
  {
    "projectId": "1291ddd9-4170-4422-a6dd-3f8ef1de3ce2",
    "testId": "8f1b3a3b-e18d-4504-9c83-28dc337fa900",
    "userId": "84d834c8-9081-7041-b0fc-d2d44446a587",
    "title": "TC015-Loading spinner and button disable during login submission",
    "description": "Ensure that while the login request is processing, a loading spinner with fade-in/zoom-in animation is visible, the login button is disabled to prevent duplicate submissions, and states are reset properly on success or failure.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:4173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Open login form.\n        frame = context.pages[-1]\n        # Click 'Enter Dashboard' button to open login form or dashboard\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Enter valid credentials and click login.\n        frame = context.pages[-1]\n        # Enter valid User ID\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('validUser')\n        \n\n        frame = context.pages[-1]\n        # Enter valid Password\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('validPassword')\n        \n\n        # -> Open login form again to retry login and verify loading spinner and button disabled state.\n        frame = context.pages[-1]\n        # Click 'Get Started' button to return to login form or start login process\n        elem = frame.locator('xpath=html/body/div/div/header/nav/div[3]/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click Login button to initiate login and verify loading spinner appears with animation and login button is disabled during loading.\n        frame = context.pages[-1]\n        # Click Login button to start login process and trigger loading spinner and button disable state\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[3]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Clear inputs, re-enter valid credentials, click Login, and immediately check for loading spinner visibility with animation and login button disabled state.\n        frame = context.pages[-1]\n        # Clear User ID input\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Clear Password input\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Re-enter valid User ID\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('validUser')\n        \n\n        frame = context.pages[-1]\n        # Re-enter valid Password\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('validPassword')\n        \n\n        frame = context.pages[-1]\n        # Click Login button to start login process and trigger loading spinner and button disable state\n        elem = frame.locator('xpath=html/body/div/div/section/div[4]/div/div/div/div[3]/div/div/div/div[3]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Login Successful! Welcome')).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The loading spinner with fade-in/zoom-in animation did not appear, or the login button was not disabled during login request processing, or states were not reset properly on success or failure as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The login process does not meet the task requirements. The loading spinner with animation and disabling of the login button during login processing are not implemented or not functioning. The login attempts immediately return an error message without showing the loading spinner or disabling the button. Task cannot be completed as specified.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84d834c8-9081-7041-b0fc-d2d44446a587/1761220380813189//tmp/test_task/result.webm",
    "created": "2025-10-23T11:46:36.634Z",
    "modified": "2025-10-23T11:53:01.028Z"
  },
  {
    "projectId": "1291ddd9-4170-4422-a6dd-3f8ef1de3ce2",
    "testId": "03a17796-caf7-4bf2-9f5d-284518f20c36",
    "userId": "84d834c8-9081-7041-b0fc-d2d44446a587",
    "title": "TC016-Image lazy loading with fade-in for dashboard previews",
    "description": "Validate that dashboard preview images are lazy loaded and fade in smoothly improving perceived performance on the landing page.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:4173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Scroll down to the dashboard preview carousel to inspect preview images for lazy loading and fade-in.\n        await page.mouse.wheel(0, 600)\n        \n\n        # -> Scroll further down and up to observe if images load only when entering viewport and if fade-in effect is visible.\n        await page.mouse.wheel(0, 400)\n        \n\n        await page.mouse.wheel(0, -400)\n        \n\n        # -> Perform network request monitoring or deeper code inspection to confirm if images are loaded lazily and if fade-in animations are applied programmatically.\n        await page.mouse.wheel(0, 300)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Building the workplace of tomorrow, today.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Seamless Ticketing, Smarter Support').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Real-time updates').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Simplified workflow').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Insightful reports').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84d834c8-9081-7041-b0fc-d2d44446a587/1761220184896975//tmp/test_task/result.webm",
    "created": "2025-10-23T11:46:36.640Z",
    "modified": "2025-10-23T11:49:45.032Z"
  },
  {
    "projectId": "1291ddd9-4170-4422-a6dd-3f8ef1de3ce2",
    "testId": "cf304f38-3cb0-4e61-8096-443a19e7b0dc",
    "userId": "84d834c8-9081-7041-b0fc-d2d44446a587",
    "title": "TC017-Animated hero section text cycle and speed",
    "description": "Test the word-by-word text reveal cycling through promotional messages with configured reveal speed, pause durations, and smooth transitions in the hero section.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:4173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Seamless attendance, smarter task management, and simpler leave cycles.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Seamless Ticketing, Smarter Support').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Real-time updates').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Simplified workflow').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Insightful reports').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84d834c8-9081-7041-b0fc-d2d44446a587/1761220216263691//tmp/test_task/result.webm",
    "created": "2025-10-23T11:46:36.646Z",
    "modified": "2025-10-23T11:50:16.461Z"
  },
  {
    "projectId": "1291ddd9-4170-4422-a6dd-3f8ef1de3ce2",
    "testId": "291db582-2191-4e78-a761-084f5a4fd932",
    "userId": "84d834c8-9081-7041-b0fc-d2d44446a587",
    "title": "TC018-Responsive layout adapts on window resize",
    "description": "Verify the application UI components including header navigation, carousels, and sections adjust their layout and behavior correctly when resizing the browser window between mobile and desktop breakpoints.",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "",
    "created": "2025-10-23T11:46:36.652Z",
    "modified": "2025-10-23T11:46:36.652Z"
  },
  {
    "projectId": "1291ddd9-4170-4422-a6dd-3f8ef1de3ce2",
    "testId": "c597c2d9-5429-45c5-bca4-188e17adfb0b",
    "userId": "84d834c8-9081-7041-b0fc-d2d44446a587",
    "title": "TC019-Clickable company logo reloads page",
    "description": "Verify that clicking the company logo in the header reloads the landing page properly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:4173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Scroll down the landing page to simulate user scroll before clicking the logo.\n        await page.mouse.wheel(0, 500)\n        \n\n        # -> Click on the company logo in the header to trigger page reload.\n        frame = context.pages[-1]\n        # Click on the company logo in the header\n        elem = frame.locator('xpath=html/body/div/div/header/nav/div[2]/div/img').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=One\\u00a0Work\\u00a0Platform\\u00a0To\\u00a0Manage\\u00a0Attendance\\u00a0&\\u00a0Tasks\\u00a0Effortlessly').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84d834c8-9081-7041-b0fc-d2d44446a587/1761220177623251//tmp/test_task/result.webm",
    "created": "2025-10-23T11:46:36.658Z",
    "modified": "2025-10-23T11:49:37.873Z"
  }
]
